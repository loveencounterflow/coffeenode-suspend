/* forked from https://github.com/jmar777/suspend.*/


(function() {
  var suspend;

  suspend = function(generator, options) {
    /* Like `https://github.com/jmar777/suspend`, but:
    * written in CoffeeScript;
    * works with callback-accepting *synchronous* functions (see below comment);
    * this means using `suspend` (or `step`) will make your code asynchronous in case it wasn't already;
    * will throw errors in the generator by default;
    * will send only a single value (not a list with a single value) to the generator if the function calling
      back did so with a single argument (otherwise no change);
    * offers utility functions for your asynchronous chores (available as `suspend.step`, `suspend.after`, and
      `suspend.eventually`);
    * more utilities possible in the future.
    */

    var do_throw, _ref;
    do_throw = (_ref = options != null ? options['throw'] : void 0) != null ? _ref : true;
    return function() {
      var iterator;
      Array.prototype.unshift.call(arguments, function(error) {
        var _arguments;
        _arguments = arguments;
        /* Here we postpone sending errors and values until the next turn of the event loop; this will
        prevent `Generator is already running` errors in case a non-asynchronous function happened to be
        called.
        */

        return suspend.eventually(function() {
          if (do_throw) {
            if (error != null) {
              return iterator["throw"](error);
            }
            if (_arguments.length < 3) {
              return iterator.send(_arguments[1]);
            } else {
              return iterator.send(Array.prototype.slice.call(_arguments, 1));
            }
          } else {
            return iterator.send(Array.prototype.slice.call(_arguments));
          }
        });
      });
      iterator = generator.apply(this, arguments);
      return iterator.next();
    };
  };

  suspend.step = function(stepper) {
    /* Like `suspend`, but executing the suspended function immediately.*/

    var R;
    R = suspend(stepper);
    return R();
  };

  suspend.after = function(time_s, handler) {
    /* `after` is a thin shim around `setTimeout` that adheres to NodeJS conventions, taking a `handler`
    callback function as last argument. Also, the timeout is given in humane seconds rather than in ms.
    */

    return setTimeout(handler, time_s * 1000);
  };

  suspend.eventually = function(handler) {
    /* `eventually f` is just another name for `process.nextTick f`â€”which in turn is basically equivalent to
    `after 0, f`.
    */

    return process.nextTick(handler);
  };

  module.exports = suspend;

}).call(this);
/****generated by https://github.com/loveencounterflow/larq****/